---
name: testing-implementation
cluster: testing-quality
description: "Concrete test tooling and patterns for TypeScript and Swift. Vitest, Testing Library, XCTest, Playwright, contract testing. Use when writing unit tests, integration tests, E2E tests, or setting up test infrastructure."
---

# Test Implementation

> **Version**: 1.4.0 | **Last updated**: 2026-02-14

## Purpose

Concrete tooling and patterns for implementing tests on every stack: TypeScript (backend/frontend), Swift (iOS).

---

## TypeScript — Backend

**Runner**: Vitest (default — Vite-compatible, fast, native ESM) or Jest (legacy, larger ecosystem).

**Unit test**: Vitest with native assertions. Mock with `vi.mock()` only for external dependencies (database, API). Prefer dependency injection + manual test doubles over mock frameworks.

```typescript
describe('Money', () => {
  it('adds two amounts with same currency', () => {
    const a = Money.create(100, 'EUR');
    const b = Money.create(50, 'EUR');
    expect(a.add(b)).toEqual(Money.create(150, 'EUR'));
  });
  it('rejects addition with different currencies', () => {
    const eur = Money.create(100, 'EUR');
    const usd = Money.create(50, 'USD');
    expect(() => eur.add(usd)).toThrow('Currency mismatch');
  });
});
```

**Integration test**: Vitest + supertest for HTTP. Database: Firestore emulator or testcontainers for PostgreSQL. Clean setup/teardown per test suite.

**Contract test**: Pact for contract testing between services. Consumer defines expectations, producer verifies. Pact files are shared CI artifacts.

### Testcontainers for Integration Tests

Testcontainers provides real database instances for integration tests — no emulators, no shared state:

```typescript
import { PostgreSqlContainer } from '@testcontainers/postgresql';
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';

let container: PostgreSqlContainer;
let db: ReturnType<typeof drizzle>;

beforeAll(async () => {
  container = await new PostgreSqlContainer('postgres:16-alpine')
    .withDatabase('test')
    .start();

  const pool = new Pool({ connectionString: container.getConnectionUri() });
  db = drizzle(pool);
  await migrate(db, { migrationsFolder: './drizzle' }); // Run migrations
}, 30_000); // Container startup timeout

afterAll(async () => {
  await container.stop();
});

describe('InvoiceRepository', () => {
  it('persists and retrieves an invoice', async () => {
    const invoice = await invoiceRepo.create(db, buildInvoice());
    const found = await invoiceRepo.findById(db, invoice.id, invoice.tenantId);
    expect(found).toEqual(invoice);
  });
});
```

### Database Test Patterns

**Transaction rollback**: wrap each test in a transaction that rolls back, ensuring test isolation without re-creating the database:

```typescript
let tx: Transaction;

beforeEach(async () => {
  tx = await db.transaction(); // Start transaction
});

afterEach(async () => {
  await tx.rollback(); // Undo all changes — fast cleanup
});
```

### Pact Contract Test Example

**Consumer side** (the service that calls an API):

```typescript
import { PactV3, MatchersV3 } from '@pact-foundation/pact';
const { like, eachLike } = MatchersV3;

const provider = new PactV3({ consumer: 'InvoiceUI', provider: 'InvoiceAPI' });

describe('Invoice API Contract', () => {
  it('returns a list of invoices', async () => {
    await provider
      .given('invoices exist for tenant')
      .uponReceiving('a request for invoices')
      .withRequest({ method: 'GET', path: '/api/v1/tenants/t_test/invoices' })
      .willRespondWith({
        status: 200,
        body: { data: eachLike({ id: like('inv_001'), amount: like(100) }) },
      })
      .executeTest(async (mockServer) => {
        const client = new InvoiceClient(mockServer.url);
        const invoices = await client.listInvoices('t_test');
        expect(invoices.data.length).toBeGreaterThan(0);
      });
  });
});
```

Pact files are generated by consumer tests and verified by provider CI — breaking contract changes are caught before deployment.

---

## TypeScript — Frontend

**Component test**: Vitest + Testing Library (React Testing Library or Vue Testing Library). Test behavior from the user's perspective (click, input, visible output), not internal implementation (state, hook calls).

```typescript
describe('InvoiceForm', () => {
  it('shows validation error for empty amount', async () => {
    render(<InvoiceForm onSubmit={vi.fn()} />);
    await userEvent.click(screen.getByRole('button', { name: /submit/i }));
    expect(screen.getByText(/amount is required/i)).toBeInTheDocument();
  });
});
```

**E2E**: Playwright (default — multi-browser, fast, modern API) or Cypress. Critical flows only. Page Object Model for maintainability. Stable tests: use data-testid for selectors, not CSS classes.

---

## Swift — iOS

**Unit test**: XCTest. Mock via protocols and test implementations (no external mock frameworks — Swift doesn't need them thanks to protocols).

```swift
final class WineCellarViewModelTests: XCTestCase {
    func test_loadWines_populatesWinesList() async {
        let mockRepo = MockWineRepository(wines: [.sampleBarolo, .sampleChianti])
        let vm = WineCellarViewModel(repository: mockRepo)
        await vm.loadWines()
        XCTAssertEqual(vm.wines.count, 2)
        XCTAssertFalse(vm.isLoading)
    }
}
```

**UI test**: XCUITest for critical E2E flows. SwiftUI previews as first-level visual verification (not a substitute for tests, but a rapid complement).

---

## Mocking External APIs

Use MSW (Mock Service Worker) for intercepting HTTP requests in tests — works at the network level, no code changes needed:

```typescript
import { setupServer } from 'msw/node';
import { http, HttpResponse } from 'msw';

const server = setupServer(
  // Mock external payment API
  http.post('https://api.stripe.com/v1/charges', () => {
    return HttpResponse.json({
      id: 'ch_test_123',
      status: 'succeeded',
      amount: 10000,
      currency: 'eur',
    });
  }),

  // Mock external email service
  http.post('https://api.sendgrid.com/v3/mail/send', () => {
    return new HttpResponse(null, { status: 202 });
  }),
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('PaymentService', () => {
  it('processes payment via Stripe', async () => {
    const result = await paymentService.charge({ amount: 100, currency: 'EUR' });
    expect(result.status).toBe('succeeded');
  });

  it('handles Stripe failure gracefully', async () => {
    server.use(
      http.post('https://api.stripe.com/v1/charges', () => {
        return HttpResponse.json({ error: { message: 'Card declined' } }, { status: 402 });
      }),
    );
    await expect(paymentService.charge({ amount: 100, currency: 'EUR' }))
      .rejects.toThrow('Card declined');
  });
});
```

MSW is preferred over `vi.mock()` for HTTP-based APIs because: it tests the real HTTP client code, works with any HTTP library, and mocks can be shared between tests.

---

## Cross-Stack Patterns

**Arrange-Act-Assert**: structure every test in three clear sections. One logical assertion per test.

**Test data factory**: helper functions producing realistic test data with sensible defaults and easy overrides.

```typescript
function buildInvoice(overrides: Partial<Invoice> = {}): Invoice {
  return {
    id: 'inv_test_001', tenantId: 't_test',
    amount: Money.create(100, 'EUR'), status: 'draft',
    createdAt: new Date('2026-01-15'), ...overrides,
  };
}
```

**No interdependent tests**: every test is independent. Execution order doesn't matter. State is reset between tests.

---

## Fuzz Testing

Automated testing with random/semi-random inputs to discover edge cases, crashes, and security vulnerabilities that hand-written tests miss. Particularly effective for parsers, validators, and protocol handlers.

### When to Fuzz

- Input parsers (JSON, XML, binary protocols, file formats)
- Validation routines and sanitizers
- Serialization/deserialization code
- Cryptographic implementations
- Any code processing untrusted external input

### Harness Design Principles

A fuzzing harness bridges the fuzzer's random byte generation and your application's API. Quality rules:

| Rule | Rationale |
|------|-----------|
| Handle all input sizes | Fuzzer generates empty, tiny, huge inputs |
| Be fast | Target 100s-1000s executions/sec — no logging, no I/O |
| Maintain determinism | Same input must always produce same behavior |
| Reset state between iterations | Global state reduces reproducibility |
| Free resources | Prevent memory exhaustion in long campaigns |

### TypeScript / Node.js — Jsfuzz

```typescript
// fuzz/parse-invoice.fuzz.ts
export function fuzz(data: Buffer) {
  try {
    const input = data.toString('utf-8');
    parseInvoicePayload(input); // Target function
  } catch (e) {
    // Expected errors from invalid input are fine
    // Unexpected crashes (TypeError, RangeError) are findings
    if (e instanceof SyntaxError || e instanceof ValidationError) return;
    throw e; // Re-throw unexpected errors for the fuzzer to catch
  }
}
```

### Rust — cargo-fuzz

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if let Ok(input) = std::str::from_utf8(data) {
        let _ = parse_invoice_payload(input);
    }
});
```

### Interleaved Fuzzing

A single harness testing multiple related operations:

```typescript
export function fuzz(data: Buffer) {
  if (data.length < 2) return;
  const mode = data[0] % 4;
  const payload = data.slice(1).toString('utf-8');

  switch (mode) {
    case 0: parseInvoice(payload); break;
    case 1: validateAmount(payload); break;
    case 2: formatCurrency(payload); break;
    case 3: sanitizeInput(payload); break;
  }
}
```

Advantage: single corpus, inputs interesting for one operation may trigger bugs in others.

### CI Integration

Run fuzz tests for a fixed duration in CI (5-10 minutes). Store corpus in a persistent location (Git LFS or artifact storage) to accumulate interesting inputs across runs.

---

## Anti-Patterns

- **Mocking everything** — tests with 5 mocks and 1 assertion test the mock framework, not the code; prefer real implementations or test containers for integration tests
- **Test coupling to implementation** — tests that break when refactoring without behavior change; test observable behavior (inputs/outputs), not internal method calls
- **Shared mutable state** — tests that pass individually but fail when run together; every test must set up and tear down its own state
- **Snapshot testing as primary strategy** — snapshots catch unintended changes but don't assert correctness; use snapshots for UI regressions, assertions for logic
- **Flaky test tolerance** — "it sometimes fails" means "it's broken"; quarantine flaky tests immediately, fix within one sprint, delete if unfixed after two sprints

---

## For Claude Code

When generating tests: one test file per significant production file, AAA structure, test data factories for reusable data, explicit error case tests, names describing expected behavior. For frontend: Testing Library (user behavior), never test internal component implementation. For fuzz testing: write harnesses for all public parsers and validators, handle expected errors gracefully, re-throw unexpected errors for the fuzzer to catch.

---

*Internal references*: `testing-strategy/SKILL.md`, `security-testing/SKILL.md`, `performance-testing/SKILL.md`
